/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#include <stdint.h>

#include "stm32f303xe.h"

static void SystemClockConfig(void);

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
  SystemClockConfig();
  /* Loop forever */
  for (;;)
    ;
}

/**
 * 		Nucleo-64 board STM32F303RE: clock configuration.
 * 		- HSE bypass mode (ST Link uC clock output, Master Clock Output
 *      (MCO)) -->  8 MHz
 * 		- SYSCLK, AHB, and APB2 with prescaler of 1
 *         --> 48 MHz
 *    - APB1 with prescaler of 2
 * 		- set PA8 as MCO with /16 prescaler
 *         -->  3 MHz
 *
 * 		This function is adapted from: http://www.pomad.fr/node/9
 */
static void SystemClockConfig(void) {
  uint32_t hse_status;
  uint32_t pll_status;
  uint32_t sw_status;
  uint32_t timeout = 1000000;

  // Set HSE bypass mode, see 9.4.1 in ref manual. Bypass mode can only be set
  // with HSE being switched off.
  RCC->CR &= ~RCC_CR_HSEON_Msk;
  RCC->CR |= RCC_CR_HSEBYP;
  RCC->CR |= RCC_CR_HSEON;

  // Wait until HSE is ready or timeout has expired.
  do {
    // HSE clock ready flag, indicates that HSE input is stable.
    hse_status = RCC->CR & RCC_CR_HSERDY_Msk;
    --timeout;
  } while ((hse_status == 0) && (timeout > 0));

  // We send the HSE input through the PLL, hence select it as PLL input
  // source, see 9.4.2.
  // First reset the PLL input clock source.
  RCC->CFGR &= ~RCC_CFGR_PLLSRC_Msk;
  // Set PLL entry clock source to 0b10: HSE/PREDIV1.
  RCC->CFGR |= (0x02 << RCC_CFGR_PLLSRC_Pos);

  // Set PLL PREDIV to /1. Can only be set if PLL is disabled.
  RCC->CR &= ~RCC_CR_PLLON_Msk;
  RCC->CFGR2 = 0x00000000;

  // Now we set the PLL multiplication factor to 6 to reach 48 MHz.
  RCC->CFGR &= ~RCC_CFGR_PLLMUL_Msk;
  RCC->CFGR |= (0x04 << RCC_CFGR_PLLMUL_Pos);

  // Enable the PLL.
  RCC->CR |= RCC_CR_PLLON;

  // Wait until the PLL is ready.
  // Reset timeout to 1000000 cycles.
  timeout = 1000000;
  do {
    pll_status = (RCC->CR & RCC_CR_PLLRDY_Msk);
    --timeout;
  } while ((pll_status == 0) && (timeout > 0));

  // Reset prescalers.
  RCC->CFGR &= ~(RCC_CFGR_HPRE_Msk | RCC_CFGR_PPRE1_Msk | RCC_CFGR_PPRE2_Msk);

  // Set AHB prescaler to /1.
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  // Set APB1 prescaler to /2, APB1 is limited to 36 MHz (see 3.1.5 and 9.2).
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;

  // Set APB2 prescaler to /1, high-speed APB..
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  // Enable Flash Prefetch Buffer and set Flash latency.
  // See here for explanation: https://electronics.stackexchange.com/a/125139
  FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;

  // Select the PLL as the system clock source, 0x10: PLL selected as SYSCLK.
  RCC->CFGR &= ~RCC_CFGR_SW_Msk;
  RCC->CFGR |= RCC_CFGR_SW_PLL;

  // Wait until system clock switch shows desired status.
  timeout = 1000000;
  do {
    sw_status = RCC->CFGR & RCC_CFGR_SWS_Msk;
    --timeout;
  } while ((sw_status != RCC_CFGR_SWS_PLL) && (timeout > 0));

  /* The microcontroller clock output capability allows the clock to be output
     onto the external MCO pin. There are different clock sources available for
     MCO (9.2.13).
    Set PA8 as MCO at 48 MHz/16 = 3 MHz. Basically to use with an oscilloscope.
    See datasheet table 14, GPIOA has MCO as SYS_AF (AF0) */

  // Select MCO source to be SYSCLK (48 MHz).
  RCC->CFGR &= ~RCC_CFGR_MCO_Msk;
  RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;

  // Set MCO prescaler to /16 (3 MHz).
  RCC->CFGR &= ~RCC_CFGR_MCOPRE_Msk;
  RCC->CFGR |= RCC_CFGR_MCOPRE_DIV16;

  // Enable GPIOA port.
  RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

  // There is only one pin that has MCO as an alternate function.
  // Select alternate function mode (0b10) for PA8. GPIOA8 is in the high
  // register
  GPIOA->MODER &= ~GPIO_MODER_MODER8_Msk;
  GPIOA->MODER |= (0x02 << GPIO_MODER_MODER8_Pos);

  // Select AF0 for PA8 (MCO output).
  GPIOA->AFR[1] &= ~GPIO_AFRH_AFRH0_Msk;
  GPIOA->AFR[1] |= (0x00 << GPIO_AFRH_AFRH0_Pos);

  // Update System Core Clock Update. Defined in system_stm32f0xx.c. Updates
  // the SystemCoreClock variable according to Clock Register Values.
  SystemCoreClockUpdate();

  // Check variable SystemCoreClock to verify SYSCLK setting.
}